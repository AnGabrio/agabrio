---
title: "Generalised Linear Mixed Models (Stan)"
author: "Andrea Gabrio"
date: '2020-02-15'
slug: glmm-stan
categories:
- generalised linear mixed models
- Stan
- R
tags:
- tutorials
- Stan
- generalised linear mixed models
subtitle: ''
summary: ''
lastmod: '2020-02-15T11:54:30+01:00'
featured: no
draft: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
bibliography: citations_stan13.bib
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>This tutorial will focus on the use of Bayesian estimation to fit simple linear regression models. <code>BUGS</code> (Bayesian inference Using <em>Gibbs Sampling</em>) is an algorithm and supporting language (resembling <code>R</code>) dedicated to performing the Gibbs sampling implementation of <em>Markov Chain Monte Carlo</em> (MCMC) method. Dialects of the <code>BUGS</code> language are implemented within three main projects:</p>
<ol style="list-style-type: decimal">
<li><p><strong>OpenBUGS</strong> - written in component pascal.</p></li>
<li><p><strong>JAGS</strong> - (Just Another Gibbs Sampler) - written in <code>C++</code>.</p></li>
<li><p><strong>Stan</strong> - a dedicated Bayesian modelling framework written in <code>C++</code> and implementing <em>Hamiltonian</em> MCMC samplers.</p></li>
</ol>
<p>Whilst the above programs can be used stand-alone, they do offer the rich data pre-processing and graphical capabilities of <code>R</code>, and thus, they are best accessed from within <code>R</code> itself. As such there are multiple packages devoted to interfacing with the various software implementations:</p>
<ul>
<li><p><em>R2OpenBUGS</em> - interfaces with <code>OpenBUGS</code></p></li>
<li><p><em>R2jags</em> - interfaces with <code>JAGS</code></p></li>
<li><p><em>rstan</em> - interfaces with <code>Stan</code></p></li>
</ul>
<p>This tutorial will demonstrate how to fit models in <code>Stan</code> (<span class="citation"><a href="#ref-gelman2015stan" role="doc-biblioref">Gelman, Lee, and Guo</a> (<a href="#ref-gelman2015stan" role="doc-biblioref">2015</a>)</span>) using the package <code>rstan</code> (<span class="citation"><a href="#ref-rstanpackage" role="doc-biblioref">Stan Development Team</a> (<a href="#ref-rstanpackage" role="doc-biblioref">2018</a>)</span>) as interface, which also requires to load some other packages.</p>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p>In some respects, <em>Generalized Linear Mixed effects Models</em> (GLMM) are a hierarchical extension of <em>Generalized linear models</em> (GLM) in a similar manner that Linear Mixed effects Models (LMM) are a hierarchical extension of Linear Models (LM). However, whilst the Gaussian (normal) distribution facilitates a relatively straight way of generating the marginal likelihood of the observed response by integrating likelihoods across all possible (and unobserved) levels of a random effect to yield parameter estimates, the same cannot be said for other distributions. Consequently various approximations have been developed to estimate the fixed and random parameters for GLMM’s:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Penalized quasi-likelihood</strong> (PQL). This method approximates a quasi-likelihood by iterative fitting of (re)weighted linear mixed effects models based on the fit of GLM fit. Specifically, it estimates the fixed effects parameters by fitting a GLM that incorporates a correlation (variance-covariance) structure resulting from a LMM and then refits a LMM to re-estimate the variance-covariance structure by using the variance structure from the previous GLM. The cycle continues to iterate until either the fit improvement is below a threshold or a defined number of iterations has occurred. Whilst this is a relatively simple approach, that enables us to leverage methodologies for accommodating heterogeneity and spatial/temporal autocorrelation, it is known to perform poorly (estimates biased towards large variance) for Poisson distributions when the expected value is less than <span class="math inline">\(5\)</span> and for binary data when the expected number of successes or failures are less than <span class="math inline">\(5\)</span>. Moreover, as it approximates quasi-likelihood rather than likelihood, likelihood based inference and information criterion methods (such as likelihood ratio tests and AIC) are not appropriate with this approach. Instead, Wald tests are required for inference.</p></li>
<li><p><strong>Laplace approximation</strong>. This approach utilises a second-order Taylor series expansion to approximate (a mathematical technique for approximating the properties of a function around a point by taking multiple derivatives of the function and summing them together) the likelihood function. If we assume that the likelihood function is approximately normal and thus a quadratic function on a log scale, we can use second-order Taylor series expansion to approximate this likelihood. Whilst this approach is considered to be more accurate than PQL, it is considerably slower and unable to accommodate alternative variance and correlation structures.</p></li>
<li><p><strong>Gauss-Hermite quadrature</strong> (GHQ). This approach approximates the marginal likelihood by approximating the value of integrals at specific points (quadratures). This technique can be further adapted by allowing the number of quadratures and their weights to be optimized via a set of rules.</p></li>
<li><p><strong>Markov-chain Monte-Carlo</strong> (MCMC). This takes a bruit force approach by recreating the likelihood by traversing the likelihood function with sequential sampling proportional to the likelihood. Although this approach is very robust (when the posteriors have converged), they are computationally very intense. Interestingly, some (including Andrew Gelman) argue that PQL, Laplace and GHQ do not yield estimates. Rather they are only approximations of estimates. By contrast, as MCMC methods are able to integrate over all levels by bruit force, the resulting parameters are indeed true estimates.</p></li>
</ol>
<p>We will focus on the last approach which is the more general among the ones considered here and which is based on a Bayesian approach, which can be very flexible and accurate, yet very slow and complex.</p>
</div>
<div id="hierarchical-poisson-regression" class="section level1">
<h1>Hierarchical Poisson regression</h1>
<p>The model I will be developing is a Bayesian hierarchical Poisson regression model which I used for the modelling of match results in volleyball, also available as a published <a href="https://www.tandfonline.com/doi/full/10.1080/02664763.2020.1723506?casa_token=5NyZAGE970gAAAAA%3AjcSlhut9cztg1nQheK_Z3NZPUuKvwUAcodvBD7g47amY1Cb-ViZZFt-ikcaYhU7o7sIzwEOOcEgH">paper</a>. The objective of the analysis is to model the match results from the season 2017-2018 of <em>Serie A1</em>, the premium Italian female volleyball league. In total there were <span class="math inline">\(136\)</span> games (rows) in the dataset each with information regarding which was the home and away team, what these teams scored, whether the match ended with <span class="math inline">\(4\)</span> or <span class="math inline">\(5\)</span> sets, and additional in-game statistics such as number of attacks, digs, serves, and blocks for each team in each match. The point outcomes of the teams in the games are assumed to be distributed according to a Poisson distribution. This model is similar to other models used for the modelling of football results, where the points scored by the home and away teams are defined as a function of latent attacking and defensive skills of the teams estimated across the games.</p>
<p>The peculiar (and novel) aspect of the model is that it takes into account the features of volleyball to generate plausible game results and league points scored by the teams across the season. In particular, for modelling purposes it is important to accout for the following aspects. 1) according to the current scoring system, matches are played until a team wins a total of three sets, with each set typically going to <span class="math inline">\(25\)</span> points. However, if the two teams won two sets each, the third set then goes only up to <span class="math inline">\(15\)</span> points. 2) a team must win each set by <span class="math inline">\(2\)</span> points. If the score is tied with even numbers, both teams have to continue playing the set until a <span class="math inline">\(2\)</span>-point lead is obtained. Otherwise, points keep accumulating until one team wins with a margin of victory of <span class="math inline">\(2\)</span> points, even if the score is greater than <span class="math inline">\(25\)</span> or <span class="math inline">\(15\)</span> points. 3) in professional volleyball leagues, the teams get points according to set numbers at the end of all matches in the league. More specifically, the team points are awarded as follows: if the match is won <span class="math inline">\(3–0\)</span> or <span class="math inline">\(3–1\)</span>, <span class="math inline">\(3\)</span> points are assigned to the winner and <span class="math inline">\(0\)</span> points to the loser; if the match is won <span class="math inline">\(3–2\)</span>, <span class="math inline">\(2\)</span> points are assigned to the winner and <span class="math inline">\(1\)</span> point to the loser.</p>
<p>The model is a Bayesian hierarchical analysis of volleyball data which allows to jointly predict match results and team rankings in national leagues. I use data from the women’s volleyball Italian Serie A1 <span class="math inline">\(2017–2018\)</span> season as a motivating example to implement and validate the model.</p>
</div>
<div id="loading-the-data" class="section level1">
<h1>Loading the data</h1>
<p>I start by loading libraries, reading in the data and preprocessing it for <code>Stan</code>. In the original verison of the analysis I used <code>JAGS</code> and a slightly more complicated model which I do not consider here, but that you may consult in my paper if interested (<span class="citation"><a href="#ref-gabrio2020bayesian" role="doc-biblioref">Gabrio</a> (<a href="#ref-gabrio2020bayesian" role="doc-biblioref">2020</a>)</span>).</p>
<pre class="r"><code>&gt; library(plyr)
&gt; library(dplyr)
&gt; library(rstan)
&gt; library(bayesplot)
&gt; library(boot)
&gt; library(ggplot2)
&gt; library(scales)
&gt; library(RColorBrewer)
&gt; library(viridis)
&gt; set.seed(12345)  # for reproducibility
&gt; 
&gt; #load data
&gt; data&lt;-read.csv(file = &quot;Volley_prepro_v1.csv&quot;,header = T)
&gt; data$home.team&lt;-as.factor(data$home.team)
&gt; data$away.team&lt;-as.factor(data$away.team)
&gt; data$bloeff1&lt;-(data$bloper1-data$bloinv1)/(data$blo1+data$bloper1)
&gt; data$bloeff2&lt;-(data$bloper2-data$bloinv2)/(data$blo2+data$bloper2)
&gt; data_stat1&lt;-ddply(data, .(h), summarise, meanatteff1=mean(atteff1),meansereff1=mean(sereff1),
+                   meandefeff1=mean(defeff1),meanbloeff1=mean(bloeff1))
&gt; data_stat2&lt;-ddply(data, .(a), summarise, meanatteff2=mean(atteff2),meansereff2=mean(sereff2),
+                   meandefeff2=mean(defeff2),meanbloeff2=mean(bloeff2))
&gt; #center cov grand mean
&gt; atteff1.cen&lt;-data$atteff1-mean(data$atteff1)
&gt; sereff1.cen&lt;-data$sereff1-mean(data$sereff1)
&gt; bloeff1.cen&lt;-data$bloeff1-mean(data$bloeff1)
&gt; defeff1.cen&lt;-data$defeff1-mean(data$defeff1)
&gt; 
&gt; atteff2.cen&lt;-data$atteff2-mean(data$atteff2)
&gt; sereff2.cen&lt;-data$sereff2-mean(data$sereff2)
&gt; bloeff2.cen&lt;-data$bloeff2-mean(data$bloeff2)
&gt; defeff2.cen&lt;-data$defeff2-mean(data$defeff2)</code></pre>
<div id="data-check" class="section level2">
<h2>Data check</h2>
<p>How are the number of points for each team in a volleyball match distributed? Well, let’s start by assuming that both teams have many chances at making a point and that each team have the same probability of scoring each point chance. Given these assumptions the distribution of the number of points for each team should be well captured by a Poisson distribution. A quick and dirty comparison between the actual distribution of the number of scored goals and a Poisson distribution having the same mean number of scored goals support this notion.</p>
<pre class="r"><code>&gt; par(mfcol = c(2, 1), mar = rep(2.2, 4))
&gt; hist(c(data$y2, data$y1), xlim = c(40, 120), breaks = 8,main = &quot;Distribution of the number of points\nscored by a team in a match.&quot;)
&gt; mean_goals &lt;- mean(c(data$y2, data$y1))
&gt; hist(rpois(9999, mean_goals), xlim = c(40, 120), breaks = 8 ,main = &quot;Random draw from a Poisson distribution with\nthe same mean as the distribution above.&quot;)</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/data_check-1.png" width="672" /></p>
</div>
<div id="model-fitting" class="section level2">
<h2>Model fitting</h2>
<p>All teams aren’t equally good and it will be assumed that all teams have a latent skill variable and the skill of a team minus the skill of the opposing team defines the predicted outcome of a game. As the number of goals are assumed to be Poisson distributed it is natural that the skills of the teams are on the log scale of the mean of the distribution. The distribution of the number of goals for the home team <span class="math inline">\(i\)</span> when facing the away team <span class="math inline">\(j\)</span> is then</p>
<p><span class="math display">\[ \text{Points} \sim \text{Pois}(\lambda)\]</span></p>
<p>where <span class="math inline">\(\log(\lambda)=\mu + \text{home} + \text{skill}_i - \text{skill}_j\)</span>. <span class="math inline">\(\mu\)</span> is a constant, while home is the advantage for the team hosting the game which is typically assumed to be constant for all the teams and throughout the season. The point outcome of a match between home team <span class="math inline">\(i\)</span> and away team <span class="math inline">\(j\)</span> is modeled as:</p>
<p><span class="math display">\[ \text{HomePoins}_{ij} \sim \text{Pois}(\lambda_{\text{home},ij}),\]</span></p>
<p><span class="math display">\[ \text{AwayPoints}_{ij} \sim \text{Pois}(\lambda_{\text{away},ij}),\]</span></p>
<p>where</p>
<p><span class="math display">\[ \log(\lambda_{\text{home},ij}) = \mu + \text{home} + \text{skill}_i - \text{skill}_j, \]</span></p>
<p><span class="math display">\[ \log(\lambda_{\text{away},ij}) = \mu + \text{skill}_j - \text{skill}_i. \]</span></p>
<p>The skill parameters for the home and away teams are specified as a function of a set of attack and defense skills, which in turn are a linear function of different in-game statistics including the number of attacks, digs, serves and blocks for each team:</p>
<p><span class="math display">\[ \text{skill}_i = \alpha_{0i} + \alpha_{1i}\text{attacks} + \alpha_{2i}\text{serves} + , \]</span></p>
<p><span class="math display">\[ \text{skill}_j = \beta_{0j} + \beta_{1j}\text{digs} + \beta_{2j}\text{blocks}, \]</span></p>
<p>The distribution of two indicator variables, related to whether or not the fifth set was played (<span class="math inline">\(d^s\)</span>) and whether the home team was the winner (<span class="math inline">\(d^g\)</span>) in each match, are aslo included in the model. These are modelled as:</p>
<p><span class="math display">\[ d^s \sim \text{Bernoulli}(\pi^s) \;\;\; \text{and} \;\;\; d^g \sim \text{Bernoulli}(\pi^g), \]</span></p>
<p>where the corresponding probabilities are specified as</p>
<p><span class="math display">\[ \text{logit}(\pi^s) = \gamma_{0} + \gamma_1\text{HomePoins}_{i} + \gamma_2\text{AwayPoins}_{j}, \]</span></p>
<p><span class="math display">\[ \text{logit}(\pi^g) = \delta_{0} + \delta_1\text{HomePoins}_{i} + \delta_2\text{AwayPoins}_{j} + \delta_3d^g. \]</span></p>
<p>I set the prior distributions over <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\text{home}\)</span> to:</p>
<p><span class="math display">\[ \text{home} \sim N(0, 10000) \;\;\; \text{and} \;\;\; \mu \sim N(0, 10000),\]</span></p>
<p>weakly informative priors on <span class="math inline">\(\boldsymbol \gamma\)</span>, <span class="math inline">\(\boldsymbol \delta\)</span>, and set the priors on the skill of all <span class="math inline">\(n\)</span> teams using a hierarchical approach to :</p>
<p><span class="math display">\[ \text{skill}_{1,\ldots,n} \sim N(\mu_{\text{teams}}, \sigma^2_{\text{teams}}),\]</span></p>
<p>so that teams are assumed to have similar but not identical mean and variance parameters for thier skill parameters. Turning this into a <code>Stan</code> model requires some minor adjustments. I have to “anchor” the sum of team skills to a constant otherwise the mean skill can drift away freely (<em>sum to zero constraint</em>) and the model cannot be identified. Doing these adjustments results in the following model description:</p>
<pre class="r"><code>&gt; rstanString&lt;-&quot;
+ data{
+ int&lt;lower=1&gt; nteams; // number of teams
+ int&lt;lower=1&gt; ngames; // number of games
+ int&lt;lower=1, upper=nteams&gt; home_team[ngames]; // home team ID (1, ..., 12)
+ int&lt;lower=1, upper=nteams&gt; away_team[ngames]; // away team ID (1, ..., 12)
+ vector [ngames] att_eff1; // in game statistics for number of attacks (home)
+ vector [ngames] ser_eff1; // in game statistics for number of serves (home)
+ vector [ngames] def_eff2; // in game statistics for number of digs (away)
+ vector [ngames] blo_eff2; // in game statistics for number of blocks (away)
+ vector [ngames] att_eff2; // in game statistics for number of attacks (away)
+ vector [ngames] ser_eff2; // in game statistics for number of serves (away)
+ vector [ngames] def_eff1; // in game statistics for number of digs (home)
+ vector [ngames] blo_eff1; // in game statistics for number of blocks (home)
+ int&lt;lower=0&gt; y1[ngames]; // number of points scored by home team
+ int&lt;lower=0&gt; y2[ngames]; // number of points scored by away team
+ int&lt;lower=0, upper=1&gt; ds[ngames]; // indicator for number of sets played (3/4 or 5)
+ int&lt;lower=0, upper=1&gt; dg[ngames]; // indicator for winning of the match for home team
+ }
+ parameters{
+ real home;
+ real mu;
+ real mu0_att;
+ real mu0_def;
+ real&lt;lower=0&gt; sigma0_att;
+ real&lt;lower=0&gt; sigma0_def;
+ real mu1_att;
+ real mu1_def;
+ real&lt;lower=0&gt; sigma1_att;
+ real&lt;lower=0&gt; sigma1_def;
+ real mu1_ser;
+ real mu1_blo;
+ real&lt;lower=0&gt; sigma1_ser;
+ real&lt;lower=0&gt; sigma1_blo;
+ vector [nteams] beta0_att_star;
+ vector [nteams] beta1_att_star;
+ vector [nteams] beta1_ser_star;
+ vector [nteams] beta0_def_star;
+ vector [nteams] beta1_def_star;
+ vector [nteams] beta1_blo_star;
+ real gamma[3];
+ real delta[4];
+ }
+ transformed parameters{
+ //Trick to code the sum-to-zero constraint
+ vector [nteams] beta0_att;
+ vector [nteams] beta1_att;
+ vector [nteams] beta1_ser;
+ vector [nteams] beta0_def;
+ vector [nteams] beta1_def;
+ vector [nteams] beta1_blo;
+ vector&lt;lower=0&gt;[ngames] theta1;
+ vector&lt;lower=0&gt;[ngames] theta2;
+ beta0_att = beta0_att_star - mean(beta0_att_star);
+ beta1_att = beta1_att_star - mean(beta1_att_star);
+ beta1_ser = beta1_ser_star - mean(beta1_ser_star);
+ beta0_def = beta0_def_star - mean(beta0_def_star);
+ beta1_def = beta1_def_star - mean(beta1_def_star);
+ beta1_blo = beta1_blo_star - mean(beta1_blo_star);
+  for (g in 1:ngames) {
+     theta1[g] = exp(home + mu + beta0_att[home_team[g]] + beta1_att[home_team[g]]*att_eff1[g] + beta1_ser[home_team[g]]*ser_eff1[g] + 
+              beta0_def[away_team[g]] + beta1_def[away_team[g]]*def_eff2[g] + beta1_blo[away_team[g]]*blo_eff2[g]); 
+     theta2[g] = exp(mu + beta0_att[away_team[g]] + beta1_att[away_team[g]]*att_eff2[g] + beta1_ser[away_team[g]]*ser_eff2[g] + 
+              beta0_def[home_team[g]] + beta1_def[home_team[g]]*def_eff1[g] + beta1_blo[home_team[g]]*blo_eff1[g]); 
+  }
+ }
+ model {
+ //priors
+ home ~ normal(0, 100);
+ mu ~ normal(0, 100);
+ mu0_att ~ normal(0, 100);
+ mu0_def ~ normal(0, 100);
+ sigma0_att ~ uniform(0, 100);
+ sigma0_def ~ uniform(0, 100);
+ mu1_att ~ normal(0, 100);
+ mu1_def ~ normal(0, 100);
+ sigma1_att ~ uniform(0, 100);
+ sigma1_def ~ uniform(0, 100);
+ mu1_ser ~ normal(0, 100);
+ mu1_blo ~ normal(0, 100);
+ sigma1_ser ~ uniform(0, 100);
+ sigma1_blo ~ uniform(0, 100);
+ gamma ~ normal(0, 100);
+ delta ~ normal(0, 100);
+ beta0_att_star ~ normal(mu0_att, sigma0_att);
+ beta0_def_star ~ normal(mu0_def, sigma0_def);
+ beta1_att_star ~ normal(mu1_att, sigma1_att);
+ beta1_def_star ~ normal(mu1_def, sigma1_def);
+ beta1_ser_star ~ normal(mu1_ser, sigma1_ser);
+ beta1_blo_star ~ normal(mu1_blo, sigma1_blo);
+ // likelihood
+  for (g in 1:ngames) {
+   y1[g] ~ poisson(theta1[g]);
+   y2[g] ~ poisson(theta2[g]);
+   ds[g] ~ bernoulli_logit(gamma[1] + gamma[2]*y1[g] + gamma[3]*y2[g]);
+   dg[g] ~ bernoulli_logit(delta[1] + delta[2]*y1[g] + delta[3]*y2[g] + delta[4]*ds[g]);
+  }
+ }
+ generated quantities{
+ // loglikelihood 
+ vector[ngames] loglik_y1;
+ vector[ngames] loglik_y2;
+ vector[ngames] loglik_ds;
+ vector[ngames] loglik_dg;
+  for (g in 1:ngames) {
+   loglik_y1[g] = poisson_lpmf(y1[g]| theta1[g]);
+   loglik_y2[g] = poisson_lpmf(y2[g]| theta2[g]);
+   loglik_ds[g] = bernoulli_logit_lpmf(ds[g]| gamma[1] + gamma[2]*y1[g] + gamma[3]*y2[g]);
+   loglik_dg[g] = bernoulli_logit_lpmf(dg[g]| delta[1] + delta[2]*y1[g] + delta[3]*y2[g] + delta[4]*ds[g]);
+  }
+ }
+ 
+ &quot;
&gt; 
&gt; ## write the model to a text file
&gt; writeLines(rstanString, con = &quot;Modelbasic.stan&quot;)</code></pre>
<p>Next, we put the data into a list to be passed to <code>Stan</code>, define the nodes (parameters and derivatives) to monitor and the chain parameters.</p>
<pre class="r"><code>&gt; #prepare data
&gt; y1&lt;-data$y1
&gt; y2&lt;-data$y2
&gt; ngames&lt;-max(data$Game)
&gt; nteams&lt;-max(data$h)
&gt; home_team&lt;-data$h
&gt; away_team&lt;-data$a
&gt; 
&gt; att_eff1&lt;-data$atteff1
&gt; att_eff2&lt;-data$atteff2
&gt; ser_eff1&lt;-data$sereff1
&gt; ser_eff2&lt;-data$sereff2
&gt; blo_eff1&lt;-data$bloeff1
&gt; blo_eff2&lt;-data$bloeff2
&gt; def_eff1&lt;-data$defeff1
&gt; def_eff2&lt;-data$defeff2
&gt; 
&gt; att_eff1&lt;-atteff1.cen
&gt; att_eff2&lt;-atteff2.cen
&gt; ser_eff1&lt;-sereff1.cen
&gt; ser_eff2&lt;-sereff2.cen
&gt; blo_eff1&lt;-bloeff1.cen
&gt; blo_eff2&lt;-bloeff2.cen
&gt; def_eff1&lt;-defeff1.cen
&gt; def_eff2&lt;-defeff2.cen
&gt; 
&gt; ds&lt;-ifelse(data$settot==5,1,0)
&gt; dg&lt;-ifelse(data$set1&gt;data$set2,1,0)
&gt; 
&gt; #pre-processing
&gt; datalist &lt;- list(y1=y1,y2=y2,ngames=ngames,nteams=nteams,home_team=home_team,away_team=away_team,att_eff1=att_eff1,att_eff2=att_eff2,def_eff1=def_eff1,def_eff2=def_eff2,ser_eff1=ser_eff1,ser_eff2=ser_eff2,blo_eff1=blo_eff1,blo_eff2=blo_eff2,ds=ds, dg=dg)
&gt; params &lt;- c(&quot;mu&quot;,&quot;home&quot;,&quot;gamma&quot;,&quot;delta&quot;,&quot;beta0_att&quot;,&quot;beta0_def&quot;,
+             &quot;beta1_att&quot;,&quot;beta1_def&quot;,&quot;beta1_ser&quot;,&quot;beta1_blo&quot;,&quot;theta1&quot;,
+             &quot;theta2&quot;,&quot;loglik_y1&quot;,&quot;loglik_y2&quot;,&quot;loglik_ds&quot;,&quot;loglik_dg&quot;)
&gt; burnInSteps = 500
&gt; nChains = 2
&gt; numSavedSteps = 2000
&gt; thinSteps = 1
&gt; nIter = ceiling((numSavedSteps * thinSteps)/nChains)</code></pre>
<p>Start the <code>Stan</code> model (check the model, load data into the model, specify the number of chains and compile the model). Run the <code>Stan</code> code via the <code>rstan</code> package and the <code>stan</code> function.</p>
<pre class="r"><code>&gt; model_stan&lt;- stan(data = datalist, file = &quot;Modelbasic.stan&quot;, 
+                        chains = nChains, pars = params, iter = nIter, 
+                        warmup = burnInSteps, thin = thinSteps)

SAMPLING FOR MODEL &#39;Modelbasic&#39; NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:   1 / 1000 [  0%]  (Warmup)
Chain 1: Iteration: 100 / 1000 [ 10%]  (Warmup)
Chain 1: Iteration: 200 / 1000 [ 20%]  (Warmup)
Chain 1: Iteration: 300 / 1000 [ 30%]  (Warmup)
Chain 1: Iteration: 400 / 1000 [ 40%]  (Warmup)
Chain 1: Iteration: 500 / 1000 [ 50%]  (Warmup)
Chain 1: Iteration: 501 / 1000 [ 50%]  (Sampling)
Chain 1: Iteration: 600 / 1000 [ 60%]  (Sampling)
Chain 1: Iteration: 700 / 1000 [ 70%]  (Sampling)
Chain 1: Iteration: 800 / 1000 [ 80%]  (Sampling)
Chain 1: Iteration: 900 / 1000 [ 90%]  (Sampling)
Chain 1: Iteration: 1000 / 1000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 80.373 seconds (Warm-up)
Chain 1:                93.512 seconds (Sampling)
Chain 1:                173.885 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL &#39;Modelbasic&#39; NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 0 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:   1 / 1000 [  0%]  (Warmup)
Chain 2: Iteration: 100 / 1000 [ 10%]  (Warmup)
Chain 2: Iteration: 200 / 1000 [ 20%]  (Warmup)
Chain 2: Iteration: 300 / 1000 [ 30%]  (Warmup)
Chain 2: Iteration: 400 / 1000 [ 40%]  (Warmup)
Chain 2: Iteration: 500 / 1000 [ 50%]  (Warmup)
Chain 2: Iteration: 501 / 1000 [ 50%]  (Sampling)
Chain 2: Iteration: 600 / 1000 [ 60%]  (Sampling)
Chain 2: Iteration: 700 / 1000 [ 70%]  (Sampling)
Chain 2: Iteration: 800 / 1000 [ 80%]  (Sampling)
Chain 2: Iteration: 900 / 1000 [ 90%]  (Sampling)
Chain 2: Iteration: 1000 / 1000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 84.528 seconds (Warm-up)
Chain 2:                94.46 seconds (Sampling)
Chain 2:                178.988 seconds (Total)
Chain 2: 
&gt; print(model_stan, pars =c(&quot;mu&quot;,&quot;home&quot;,&quot;gamma&quot;,&quot;delta&quot;,&quot;beta0_att&quot;,
+                           &quot;beta0_def&quot;,&quot;beta1_att&quot;,&quot;beta1_def&quot;,
+                           &quot;beta1_ser&quot;,&quot;beta1_blo&quot;))
Inference for Stan model: Modelbasic.
2 chains, each with iter=1000; warmup=500; thin=1; 
post-warmup draws per chain=500, total post-warmup draws=1000.

                mean se_mean    sd    2.5%     25%    50%    75%  97.5% n_eff
mu              4.44    0.00  0.01    4.42    4.43   4.44   4.45   4.47   108
home            0.03    0.00  0.01    0.01    0.02   0.03   0.04   0.06   121
gamma[1]      -96.80    4.01 26.64 -158.23 -112.87 -92.91 -77.16 -54.18    44
gamma[2]        0.48    0.02  0.17    0.21    0.36   0.47   0.58   0.88    63
gamma[3]        0.51    0.02  0.15    0.28    0.39   0.49   0.60   0.83    57
delta[1]      -10.71    0.83  5.46  -20.91  -14.66 -10.37  -6.71  -0.48    43
delta[2]        0.45    0.02  0.11    0.26    0.37   0.44   0.52   0.67    32
delta[3]       -0.32    0.01  0.07   -0.49   -0.36  -0.31  -0.27  -0.20    46
delta[4]       -2.85    0.17  1.42   -5.77   -3.79  -2.77  -1.87  -0.33    71
beta0_att[1]   -0.01    0.00  0.02   -0.06   -0.03  -0.01   0.01   0.04   887
beta0_att[2]    0.02    0.00  0.02   -0.03    0.00   0.02   0.03   0.06  1075
beta0_att[3]    0.02    0.00  0.02   -0.02    0.01   0.02   0.04   0.07  1023
beta0_att[4]    0.01    0.00  0.02   -0.04   -0.01   0.01   0.02   0.05  1053
beta0_att[5]   -0.07    0.00  0.03   -0.13   -0.09  -0.07  -0.05  -0.02   932
beta0_att[6]   -0.09    0.00  0.03   -0.14   -0.11  -0.09  -0.07  -0.04   537
beta0_att[7]    0.03    0.00  0.02   -0.02    0.01   0.03   0.04   0.08   969
beta0_att[8]    0.14    0.00  0.04    0.07    0.11   0.14   0.16   0.20   267
beta0_att[9]   -0.05    0.00  0.02   -0.10   -0.06  -0.05  -0.03   0.00  1057
beta0_att[10]   0.01    0.00  0.02   -0.04   -0.01   0.01   0.02   0.06   546
beta0_att[11]  -0.01    0.00  0.02   -0.06   -0.03  -0.01   0.00   0.03   914
beta0_att[12]   0.02    0.00  0.03   -0.04    0.00   0.02   0.03   0.07   837
beta0_def[1]    0.04    0.00  0.02    0.00    0.03   0.04   0.06   0.08   991
beta0_def[2]    0.06    0.00  0.03    0.00    0.04   0.06   0.07   0.11   590
beta0_def[3]    0.08    0.00  0.02    0.04    0.07   0.08   0.10   0.13  1023
beta0_def[4]   -0.08    0.00  0.02   -0.12   -0.10  -0.08  -0.07  -0.04   906
beta0_def[5]    0.03    0.00  0.02   -0.02    0.01   0.03   0.05   0.08   815
beta0_def[6]    0.01    0.00  0.02   -0.03    0.00   0.02   0.03   0.06   912
beta0_def[7]    0.05    0.00  0.02    0.00    0.03   0.05   0.06   0.10   728
beta0_def[8]   -0.01    0.00  0.03   -0.06   -0.02  -0.01   0.01   0.05   902
beta0_def[9]   -0.03    0.00  0.02   -0.08   -0.05  -0.03  -0.02   0.01   935
beta0_def[10]   0.03    0.00  0.02   -0.02    0.02   0.03   0.05   0.08   830
beta0_def[11]   0.01    0.00  0.03   -0.04   -0.01   0.01   0.02   0.06   708
beta0_def[12]  -0.19    0.00  0.04   -0.26   -0.21  -0.19  -0.16  -0.12   268
beta1_att[1]    0.35    0.01  0.37   -0.37    0.11   0.35   0.59   1.09   803
beta1_att[2]   -0.88    0.01  0.37   -1.66   -1.14  -0.87  -0.62  -0.20   697
beta1_att[3]    0.31    0.01  0.36   -0.42    0.08   0.30   0.55   0.99   897
beta1_att[4]    0.21    0.01  0.36   -0.46   -0.03   0.21   0.44   0.90   978
beta1_att[5]   -0.14    0.01  0.38   -0.88   -0.40  -0.14   0.10   0.65   831
beta1_att[6]    0.95    0.02  0.37    0.25    0.70   0.94   1.20   1.68   595
beta1_att[7]   -0.53    0.02  0.48   -1.55   -0.86  -0.52  -0.21   0.35   922
beta1_att[8]   -2.07    0.04  0.59   -3.23   -2.44  -2.08  -1.66  -0.93   254
beta1_att[9]    0.78    0.01  0.34    0.16    0.55   0.78   1.00   1.43   715
beta1_att[10]   0.03    0.01  0.43   -0.83   -0.24   0.01   0.31   0.86   882
beta1_att[11]   1.15    0.02  0.37    0.42    0.89   1.15   1.41   1.84   556
beta1_att[12]  -0.16    0.00  0.05   -0.25   -0.19  -0.16  -0.12  -0.06   922
beta1_def[1]    0.12    0.01  0.17   -0.21    0.01   0.13   0.24   0.45   931
beta1_def[2]    0.03    0.00  0.13   -0.22   -0.05   0.03   0.11   0.29   887
beta1_def[3]    0.00    0.00  0.15   -0.29   -0.11  -0.01   0.10   0.29   928
beta1_def[4]    0.28    0.01  0.18   -0.07    0.15   0.28   0.40   0.65   890
beta1_def[5]    0.08    0.01  0.16   -0.23   -0.04   0.08   0.20   0.41   764
beta1_def[6]    0.05    0.01  0.17   -0.27   -0.06   0.04   0.15   0.40   748
beta1_def[7]   -0.18    0.01  0.19   -0.53   -0.30  -0.19  -0.05   0.19   783
beta1_def[8]   -0.73    0.01  0.16   -1.06   -0.84  -0.72  -0.62  -0.43   538
beta1_def[9]   -0.07    0.01  0.15   -0.38   -0.18  -0.07   0.03   0.23   767
beta1_def[10]   0.02    0.00  0.14   -0.26   -0.08   0.01   0.11   0.28   853
beta1_def[11]   0.00    0.01  0.14   -0.29   -0.09   0.00   0.09   0.26   736
beta1_def[12]   0.40    0.01  0.17    0.08    0.29   0.39   0.51   0.73   715
beta1_ser[1]    0.14    0.02  0.53   -0.86   -0.21   0.14   0.48   1.21   995
beta1_ser[2]    0.49    0.02  0.52   -0.51    0.15   0.49   0.82   1.54   621
beta1_ser[3]    0.74    0.02  0.44   -0.11    0.44   0.73   1.05   1.63   800
beta1_ser[4]   -0.67    0.02  0.41   -1.48   -0.94  -0.64  -0.38   0.14   731
beta1_ser[5]    1.29    0.02  0.45    0.47    0.97   1.27   1.57   2.26   419
beta1_ser[6]   -0.40    0.02  0.59   -1.60   -0.77  -0.38   0.00   0.68   787
beta1_ser[7]   -0.91    0.02  0.57   -2.15   -1.26  -0.89  -0.52   0.15   541
beta1_ser[8]   -0.01    0.02  0.52   -1.00   -0.34  -0.01   0.32   1.04   996
beta1_ser[9]   -0.02    0.02  0.51   -1.02   -0.34  -0.04   0.33   0.96   931
beta1_ser[10]  -0.59    0.02  0.48   -1.60   -0.90  -0.61  -0.26   0.29   843
beta1_ser[11]   0.95    0.02  0.49    0.00    0.64   0.94   1.26   1.97   614
beta1_ser[12]  -1.02    0.02  0.45   -1.93   -1.30  -1.01  -0.73  -0.17   762
beta1_blo[1]   -0.01    0.00  0.09   -0.19   -0.07  -0.01   0.06   0.17  1072
beta1_blo[2]   -0.19    0.01  0.11   -0.44   -0.27  -0.19  -0.11   0.01   281
beta1_blo[3]   -0.02    0.00  0.06   -0.14   -0.07  -0.03   0.02   0.11   863
beta1_blo[4]   -0.04    0.00  0.06   -0.17   -0.08  -0.04   0.00   0.08   944
beta1_blo[5]    0.15    0.00  0.10   -0.03    0.08   0.15   0.22   0.34   447
beta1_blo[6]    0.01    0.00  0.06   -0.11   -0.03   0.01   0.05   0.12   957
beta1_blo[7]    0.09    0.00  0.07   -0.05    0.04   0.09   0.13   0.23   706
beta1_blo[8]   -0.08    0.00  0.11   -0.32   -0.16  -0.08   0.00   0.11   663
beta1_blo[9]   -0.15    0.00  0.08   -0.30   -0.20  -0.15  -0.09   0.01   467
beta1_blo[10]  -0.02    0.00  0.05   -0.13   -0.06  -0.02   0.01   0.08   788
beta1_blo[11]  -0.01    0.00  0.08   -0.17   -0.06  -0.01   0.05   0.15   954
beta1_blo[12]   0.29    0.01  0.13    0.04    0.19   0.28   0.37   0.55   229
              Rhat
mu            1.01
home          1.01
gamma[1]      1.04
gamma[2]      1.03
gamma[3]      1.03
delta[1]      1.04
delta[2]      1.06
delta[3]      1.04
delta[4]      1.03
beta0_att[1]  1.00
beta0_att[2]  1.01
beta0_att[3]  1.00
beta0_att[4]  1.00
beta0_att[5]  1.00
beta0_att[6]  1.01
beta0_att[7]  1.00
beta0_att[8]  1.00
beta0_att[9]  1.00
beta0_att[10] 1.01
beta0_att[11] 1.00
beta0_att[12] 1.00
beta0_def[1]  1.00
beta0_def[2]  1.00
beta0_def[3]  1.00
beta0_def[4]  1.00
beta0_def[5]  1.00
beta0_def[6]  1.00
beta0_def[7]  1.00
beta0_def[8]  1.00
beta0_def[9]  1.00
beta0_def[10] 1.00
beta0_def[11] 1.00
beta0_def[12] 1.00
beta1_att[1]  1.00
beta1_att[2]  1.00
beta1_att[3]  1.00
beta1_att[4]  1.00
beta1_att[5]  1.00
beta1_att[6]  1.00
beta1_att[7]  1.00
beta1_att[8]  1.00
beta1_att[9]  1.00
beta1_att[10] 1.00
beta1_att[11] 1.00
beta1_att[12] 1.00
beta1_def[1]  1.00
beta1_def[2]  1.00
beta1_def[3]  1.00
beta1_def[4]  1.00
beta1_def[5]  1.00
beta1_def[6]  1.01
beta1_def[7]  1.00
beta1_def[8]  1.00
beta1_def[9]  1.00
beta1_def[10] 1.00
beta1_def[11] 1.00
beta1_def[12] 1.00
beta1_ser[1]  1.00
beta1_ser[2]  1.00
beta1_ser[3]  1.00
beta1_ser[4]  1.00
beta1_ser[5]  1.00
beta1_ser[6]  1.00
beta1_ser[7]  1.00
beta1_ser[8]  1.00
beta1_ser[9]  1.00
beta1_ser[10] 1.00
beta1_ser[11] 1.00
beta1_ser[12] 1.00
beta1_blo[1]  1.00
beta1_blo[2]  1.01
beta1_blo[3]  1.00
beta1_blo[4]  1.00
beta1_blo[5]  1.01
beta1_blo[6]  1.00
beta1_blo[7]  1.00
beta1_blo[8]  1.00
beta1_blo[9]  1.01
beta1_blo[10] 1.00
beta1_blo[11] 1.00
beta1_blo[12] 1.01

Samples were drawn using NUTS(diag_e) at Thu Jul 08 21:02:58 2021.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).</code></pre>
<p>The diagnostic results are not perfect, perhaps I should run the algorithm a bit longer to get better results as a total of <span class="math inline">\(1000\)</span> iterations does not seem enough. Here I do not bother to save time. To get an idea about posterior results I can plot at the average marginal mean offensive and defensive skills for each of the <span class="math inline">\(12\)</span> teams in the league using the following code.</p>
<pre class="r"><code>&gt; #plot att vs def effext by team
&gt; model_stan_par&lt;-extract(model_stan)
&gt; 
&gt; beta0.att&lt;-apply(model_stan_par$beta0_att, 2, mean)
&gt; beta0.def&lt;-apply(model_stan_par$beta0_def, 2, mean)
&gt; names&lt;-unique(data.frame(data$home.team,data$h)[order(data$h),][,1])
&gt; 
&gt; plot(beta0.att,beta0.def, main = &quot;&quot;, type = &quot;n&quot;, xlab = &quot;Mean attack effect&quot;, ylab = &quot;Mean defence effect&quot;, xlim=c(-0.13,0.08), ylim=c(-0.18,0.1))
&gt; points(beta0.att,beta0.def, pch=16, col=&quot;red&quot;,cex = 1.2)
&gt; abline(v=0)
&gt; abline(h=0)
&gt; text(beta0.att,beta0.def,names,cex = 0.8, adj = c(0.4,1.3))</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/effects-1.png" width="672" /></p>
<p>Different clusters of teams can be easily detected and suggest a different performance of the teams based on their average offensive and defensive skills. Those associated with higher offensive (to the right) and lower defensive (to the bottom) effects are the ones with the best performance across the season.</p>
</div>
<div id="mcmc-diagnostics" class="section level2">
<h2>MCMC diagnostics</h2>
<p>Using the generated MCMC samples I can now look at some diagnostic measures. For example, we can assess convergence of the chains using the function <code>mcmc_combo</code> in the package <code>bayesplot</code> which provides a summary of convergence diagnostics using different graphics. We consider the marginal skill parameters for four teams to give an example.</p>
<pre class="r"><code>&gt; mcmc_combo(model_stan, pars=c(&quot;beta0_att[1]&quot;,&quot;beta0_att[2]&quot;,
+                               &quot;beta0_att[3]&quot;,&quot;beta0_att[4]&quot;))</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/mcmc_diag-1.png" width="672" /></p>
<pre class="r"><code>&gt; mcmc_combo(model_stan, pars=c(&quot;beta0_def[1]&quot;,&quot;beta0_def[2]&quot;,
+                               &quot;beta0_def[3]&quot;,&quot;beta0_def[4]&quot;))</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/mcmc_diag-2.png" width="672" /></p>
</div>
<div id="model-validation" class="section level2">
<h2>Model validation</h2>
<p>We can finally assess the fit of the model to the data by computing posterior predictive checks, where we use the posterior values of the parameters to sample a large number of replications for the data. We then use these to generate different types of results and compare them with the actual results to detect possible misfits of the model.</p>
<pre class="r"><code>&gt; #obtain parameters to generate replications
&gt; y1.pred&lt;-y2.pred&lt;-matrix(NA,length(model_stan_par$home),132)
&gt; ds.pred&lt;-dg.pred&lt;-matrix(NA,length(model_stan_par$home),132)
&gt; pi.s&lt;-pi.g&lt;-matrix(NA,length(model_stan_par$home),132)
&gt; y1.mat&lt;-y2.mat&lt;-ds.mat&lt;-matrix(NA,length(model_stan_par$home),132)
&gt; for(i in 1:length(model_stan_par$home)){
+  y1.mat[i,]&lt;-y1
+  y2.mat[i,]&lt;-y2
+  ds.mat[i,]&lt;-ds
+  pi.s[i,]&lt;-inv.logit(model_stan_par$gamma[i,1] + model_stan_par$gamma[i,2]*y1.mat[i,] + model_stan_par$gamma[i,3]*y2.mat[i,])
+  pi.g[i,]&lt;-inv.logit(model_stan_par$delta[i,1] + model_stan_par$delta[i,2]*y1.mat[i,] + model_stan_par$delta[i,3]*y2.mat[i,] + model_stan_par$delta[i,4]*ds.mat[i,])
+ }
&gt; 
&gt; #generate predictions
&gt; set.seed(3456)
&gt; for(i in 1:length(model_stan_par$home)){
+   y1.pred[i,]&lt;-rpois(n=132,lambda = model_stan_par$theta1[i,])
+   y2.pred[i,]&lt;-rpois(n=132,lambda = model_stan_par$theta2[i,])
+   ds.pred[i,]&lt;-rbinom(n=132, size = 1,prob = pi.s[i,])
+   dg.pred[i,]&lt;-rbinom(n=132, size = 1,prob = pi.g[i,])
+ }
&gt; 
&gt; #compute prediction points
&gt; results&lt;-list()
&gt; for(i in 1:1000){
+   results[[i]]&lt;-data.frame(y1.pred[i,],y2.pred[i,],ds.pred[i,],dg.pred[i,],data$h,data$a) 
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==0 &amp; results[[i]]$dg.pred.i...==1,3,0)
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==1,2,results[[i]]$points.home)
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==0,1,results[[i]]$points.home)
+   
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==0 &amp; results[[i]]$dg.pred.i...==0,3,0)
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==0,2,results[[i]]$points.away)
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==1,1,results[[i]]$points.away)
+ }
&gt; 
&gt; #compare results for scores by team
&gt; tot.y1.list&lt;-tot.y2.list&lt;-list()
&gt; for(i in 1:1000){
+   tot.y1.list[[i]]&lt;-ddply(results[[i]], .(data.h), summarise, totscorehome=sum(y1.pred.i...))
+   tot.y2.list[[i]]&lt;-ddply(results[[i]], .(data.a), summarise, totscoreaway=sum(y2.pred.i...))
+ }
&gt; tot.y1.list.neg&lt;-tot.y2.list.neg&lt;-list()
&gt; for(i in 1:1000){
+   tot.y1.list.neg[[i]]&lt;-ddply(results[[i]], .(data.h), summarise, totscorehomeneg=sum(y2.pred.i...))
+   tot.y2.list.neg[[i]]&lt;-ddply(results[[i]], .(data.a), summarise, totscoreawayneg=sum(y1.pred.i...))
+ }
&gt; 
&gt; 
&gt; tot.y1.list.mat&lt;-tot.y2.list.mat&lt;-matrix(NA,1000,12)
&gt; tot.y1.list.neg.mat&lt;-tot.y2.list.neg.mat&lt;-matrix(NA,1000,12)
&gt; for(i in 1:1000){
+   tot.y1.list.mat[i,]&lt;-tot.y1.list[[i]][,2]
+   tot.y2.list.mat[i,]&lt;-tot.y2.list[[i]][,2]
+   tot.y1.list.neg.mat[i,]&lt;-tot.y1.list.neg[[i]][,2]
+   tot.y2.list.neg.mat[i,]&lt;-tot.y2.list.neg[[i]][,2]
+ }
&gt; tot.y1.obs&lt;-ddply(data, .(h), summarise, totscorehomeobs=sum(y1))
&gt; tot.y2.obs&lt;-ddply(data, .(a), summarise, totscorehomeobs=sum(y2))
&gt; tot.y1.obs.neg&lt;-ddply(data, .(h), summarise, totscorehomeobs=sum(y2))
&gt; tot.y2.obs.neg&lt;-ddply(data, .(a), summarise, totscorehomeobs=sum(y1))
&gt; 
&gt; #compute prediction points
&gt; results&lt;-list()
&gt; for(i in 1:1000){
+   results[[i]]&lt;-data.frame(y1.pred[i,],y2.pred[i,],ds.pred[i,],dg.pred[i,],data$h,data$a) 
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==0 &amp; results[[i]]$dg.pred.i...==1,3,0)
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==1,2,results[[i]]$points.home)
+   results[[i]]$points.home&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==0,1,results[[i]]$points.home)
+   
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==0 &amp; results[[i]]$dg.pred.i...==0,3,0)
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==0,2,results[[i]]$points.away)
+   results[[i]]$points.away&lt;-ifelse(results[[i]]$ds.pred.i...==1 &amp; results[[i]]$dg.pred.i...==1,1,results[[i]]$points.away)
+ }
&gt; 
&gt; #compare results for scores by team
&gt; tot.y1.list&lt;-tot.y2.list&lt;-list()
&gt; for(i in 1:1000){
+   tot.y1.list[[i]]&lt;-ddply(results[[i]], .(data.h), summarise, totscorehome=sum(y1.pred.i...))
+   tot.y2.list[[i]]&lt;-ddply(results[[i]], .(data.a), summarise, totscoreaway=sum(y2.pred.i...))
+ }
&gt; tot.y1.list.neg&lt;-tot.y2.list.neg&lt;-list()
&gt; for(i in 1:1000){
+   tot.y1.list.neg[[i]]&lt;-ddply(results[[i]], .(data.h), summarise, totscorehomeneg=sum(y2.pred.i...))
+   tot.y2.list.neg[[i]]&lt;-ddply(results[[i]], .(data.a), summarise, totscoreawayneg=sum(y1.pred.i...))
+ }
&gt; 
&gt; 
&gt; tot.y1.list.mat&lt;-tot.y2.list.mat&lt;-matrix(NA,1000,12)
&gt; tot.y1.list.neg.mat&lt;-tot.y2.list.neg.mat&lt;-matrix(NA,1000,12)
&gt; for(i in 1:1000){
+   tot.y1.list.mat[i,]&lt;-tot.y1.list[[i]][,2]
+   tot.y2.list.mat[i,]&lt;-tot.y2.list[[i]][,2]
+   tot.y1.list.neg.mat[i,]&lt;-tot.y1.list.neg[[i]][,2]
+   tot.y2.list.neg.mat[i,]&lt;-tot.y2.list.neg[[i]][,2]
+ }
&gt; tot.y1.obs&lt;-ddply(data, .(h), summarise, totscorehomeobs=sum(y1))
&gt; tot.y2.obs&lt;-ddply(data, .(a), summarise, totscorehomeobs=sum(y2))
&gt; tot.y1.obs.neg&lt;-ddply(data, .(h), summarise, totscorehomeobs=sum(y2))
&gt; tot.y2.obs.neg&lt;-ddply(data, .(a), summarise, totscorehomeobs=sum(y1))
&gt; 
&gt; #scored
&gt; tot.y.obs&lt;-tot.y1.obs[,2]+tot.y2.obs[,2]
&gt; tot.y.pred&lt;-apply(tot.y1.list.mat,2,median)+apply(tot.y2.list.mat,2,median)
&gt; res.y&lt;-cbind(tot.y.obs,tot.y.pred)
&gt; rownames(res.y)&lt;-names
&gt; res.y&lt;-round(res.y,digits = 0)
&gt; 
&gt; #conceded
&gt; tot.y.obs.neg&lt;-tot.y1.obs.neg[,2]+tot.y2.obs.neg[,2]
&gt; tot.y.pred.neg&lt;-apply(tot.y1.list.neg.mat,2,median)+apply(tot.y2.list.neg.mat,2,median)
&gt; res.y.neg&lt;-cbind(tot.y.obs.neg,tot.y.pred.neg)
&gt; rownames(res.y.neg)&lt;-names
&gt; res.y.neg&lt;-round(res.y.neg,digits = 0)
&gt; 
&gt; #compare results for points
&gt; data.points.list&lt;-list()
&gt; for(i in 1:1000){
+   data.points.list[[i]]&lt;-data.frame(data$Game)
+   data.points.list[[i]]$Game&lt;-data$Game
+   data.points.list[[i]]$h&lt;-data$h
+   data.points.list[[i]]$a&lt;-data$a
+   data.points.list[[i]]$points.home&lt;-results[[i]]$points.home
+   data.points.list[[i]]$points.away&lt;-results[[i]]$points.away
+ }
&gt; tot.home.list&lt;-tot.away.list&lt;-tot.team.list&lt;-list()
&gt; for(i in 1:1000){
+   tot.home.list[[i]]&lt;-ddply(data.points.list[[i]], .(h), summarise, totpointhome=sum(points.home))
+   tot.away.list[[i]]&lt;-ddply(data.points.list[[i]], .(a), summarise, totpointaway=sum(points.away))
+ }
&gt; 
&gt; for(i in 1:1000){
+   tot.team.list[[i]]&lt;-data.frame(levels(data$home.team), tot.home.list[[i]]$h)
+   tot.team.list[[i]]$tot.team&lt;-tot.home.list[[i]]$totpointhome + tot.away.list[[i]]$totpointaway
+   tot.team.list[[i]]$true.team&lt;-c(19, 39, 23, 50, 19, 11, 37, 51, 32, 33, 27, 50)
+   tot.team.list[[i]]&lt;-tot.team.list[[i]][order(tot.team.list[[i]]$tot.team, decreasing = TRUE),]
+   tot.team.list[[i]]$rank&lt;-rep(1:12)
+ }
&gt; 
&gt; #plot total scores by team
&gt; tot.scores&lt;-matrix(NA,1000,12)
&gt; colnames(tot.scores)&lt;-names
&gt; for(i in 1:1000){
+   for(j in 1:12){
+     tot.scores[i,j]&lt;-tot.team.list[[i]]$tot.team[tot.team.list[[i]]$tot.home.list..i...h==j] 
+   }
+ }
&gt; tot.scores.obs&lt;-c(19, 39, 23, 50, 19, 11, 37, 51, 32, 33, 27, 50)
&gt; tot.scores.med&lt;-apply(tot.scores, 2, median)
&gt; tot.scores.final&lt;-cbind(tot.scores.obs,tot.scores.med)
&gt; 
&gt; #plot total wins 
&gt; tot.wins&lt;-matrix(NA,1000,12)
&gt; colnames(tot.wins)&lt;-names
&gt; for(i in 1:1000){
+   for(j in 1:12){
+     tot.wins[i,j]&lt;-length(data.points.list[[i]]$points.home[data.points.list[[i]]$points.home&gt;1 &amp; 
+                                                               data.points.list[[i]]$h==j]) + length(data.points.list[[i]]$points.away[data.points.list[[i]]$points.away&gt;1 &amp; 
+                                                                                                                                         data.points.list[[i]]$a==j])
+   }
+ }
&gt; tot.wins.obs&lt;-c(7,12,6,17,7,5,13,17,10,12,8,18)
&gt; tot.wins.prop&lt;-tot.wins/22
&gt; tot.wins.obs.prop&lt;-tot.wins.obs/22
&gt; tot.wins.med&lt;-apply(tot.wins, 2, median)
&gt; tot.wins.final&lt;-cbind(tot.wins.obs,tot.wins.med)</code></pre>
<p>Here, for each team, we compare the predicted and observed total number of points scored in the matches, the number of won/lost matches, and the league points scored based on a replicated and the original season results.</p>
<pre class="r"><code>&gt; #summarise pred results
&gt; res.final.obs&lt;-cbind(res.y[,1],res.y.neg[,1],tot.wins.final[,1],tot.scores.final[,1])
&gt; res.final.pred&lt;-cbind(res.y[,2],res.y.neg[,2],tot.wins.final[,2],tot.scores.final[,2])
&gt; res.final&lt;-cbind(res.final.obs,res.final.pred)
&gt; colnames(res.final)&lt;-c(&quot;scored&quot;,&quot;conc&#39;d&quot;,&quot;wins&quot;,&quot;points&quot;,&quot;scored&quot;,&quot;conc&#39;d&quot;,&quot;wins&quot;,&quot;points&quot;)
&gt; knitr::kable(res.final, &quot;pandoc&quot;, align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th></th>
<th align="center">scored</th>
<th align="center">conc’d</th>
<th align="center">wins</th>
<th align="center">points</th>
<th align="center">scored</th>
<th align="center">conc’d</th>
<th align="center">wins</th>
<th align="center">points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bergamo</td>
<td align="center">1848</td>
<td align="center">2025</td>
<td align="center">7</td>
<td align="center">19</td>
<td align="center">1850</td>
<td align="center">2016</td>
<td align="center">7</td>
<td align="center">20.5</td>
</tr>
<tr class="even">
<td>Busto Arsizio</td>
<td align="center">1999</td>
<td align="center">1927</td>
<td align="center">12</td>
<td align="center">39</td>
<td align="center">1995</td>
<td align="center">1918</td>
<td align="center">12</td>
<td align="center">37.0</td>
</tr>
<tr class="odd">
<td>Casalmaggiore</td>
<td align="center">1922</td>
<td align="center">2051</td>
<td align="center">6</td>
<td align="center">23</td>
<td align="center">1914</td>
<td align="center">2034</td>
<td align="center">7</td>
<td align="center">23.0</td>
</tr>
<tr class="even">
<td>Conegliano</td>
<td align="center">1960</td>
<td align="center">1696</td>
<td align="center">17</td>
<td align="center">50</td>
<td align="center">1957</td>
<td align="center">1708</td>
<td align="center">18</td>
<td align="center">50.0</td>
</tr>
<tr class="odd">
<td>Filottrano</td>
<td align="center">1781</td>
<td align="center">1961</td>
<td align="center">7</td>
<td align="center">19</td>
<td align="center">1794</td>
<td align="center">1953</td>
<td align="center">6</td>
<td align="center">18.0</td>
</tr>
<tr class="even">
<td>Legnano</td>
<td align="center">1642</td>
<td align="center">1903</td>
<td align="center">5</td>
<td align="center">11</td>
<td align="center">1662</td>
<td align="center">1902</td>
<td align="center">4</td>
<td align="center">17.0</td>
</tr>
<tr class="odd">
<td>Monza</td>
<td align="center">2003</td>
<td align="center">1943</td>
<td align="center">13</td>
<td align="center">37</td>
<td align="center">1998</td>
<td align="center">1934</td>
<td align="center">13</td>
<td align="center">38.0</td>
</tr>
<tr class="even">
<td>Novara</td>
<td align="center">1987</td>
<td align="center">1776</td>
<td align="center">17</td>
<td align="center">51</td>
<td align="center">1953</td>
<td align="center">1778</td>
<td align="center">17</td>
<td align="center">51.0</td>
</tr>
<tr class="odd">
<td>Pesaro</td>
<td align="center">1776</td>
<td align="center">1820</td>
<td align="center">10</td>
<td align="center">32</td>
<td align="center">1788</td>
<td align="center">1825</td>
<td align="center">11</td>
<td align="center">32.0</td>
</tr>
<tr class="even">
<td>Piacenza</td>
<td align="center">1888</td>
<td align="center">1939</td>
<td align="center">12</td>
<td align="center">33</td>
<td align="center">1884</td>
<td align="center">1932</td>
<td align="center">9</td>
<td align="center">30.0</td>
</tr>
<tr class="odd">
<td>San Casciano</td>
<td align="center">1807</td>
<td align="center">1881</td>
<td align="center">8</td>
<td align="center">27</td>
<td align="center">1812</td>
<td align="center">1880</td>
<td align="center">9</td>
<td align="center">29.0</td>
</tr>
<tr class="even">
<td>Scandicci</td>
<td align="center">1865</td>
<td align="center">1556</td>
<td align="center">18</td>
<td align="center">50</td>
<td align="center">1856</td>
<td align="center">1589</td>
<td align="center">18</td>
<td align="center">51.0</td>
</tr>
</tbody>
</table>
<p>Predicted results (the last four columns in the table) are not so bad, especially when looking at the number of league points scored by the teams between the replicated and observed season which are quite similar. These results suggest that the model seems to predict in a reasonable way the league results. To further assess this aspect, we consider two plots. The first compares the ranking of the teams across a large number of replications of the season based on the number of wins, losses and league points gained for each team.</p>
<pre class="r"><code>&gt; #summarise pred results
&gt; res.matrix&lt;-matrix(NA,length(tot.team.list),12)
&gt; colnames(res.matrix)&lt;-names
&gt; for(i in 1:1000){
+   res.matrix[i,1]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==1]
+   res.matrix[i,2]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==2]
+   res.matrix[i,3]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==3]
+   res.matrix[i,4]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==4]
+   res.matrix[i,5]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==5]
+   res.matrix[i,6]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==6]
+   res.matrix[i,7]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==7]
+   res.matrix[i,8]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==8]
+   res.matrix[i,9]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==9]
+   res.matrix[i,10]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==10]
+   res.matrix[i,11]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==11]
+   res.matrix[i,12]&lt;-tot.team.list[[i]]$rank[tot.team.list[[i]]$tot.home.list..i...h==12]
+ }
&gt; 
&gt; #create stacked barplot of results
&gt; data.barplot&lt;-data.frame(rep(1:c(1000*12)))
&gt; names(data.barplot)&lt;-c(&quot;Game&quot;)
&gt; data.barplot$position&lt;-as.factor(c(res.matrix[,1],res.matrix[,2],res.matrix[,3],res.matrix[,4],
+                                    res.matrix[,5],res.matrix[,6],res.matrix[,7],res.matrix[,8],
+                                    res.matrix[,9],res.matrix[,10],res.matrix[,11],res.matrix[,12]))
&gt; data.barplot$team&lt;-rep(NA,1000*12)
&gt; data.barplot$team[1:1000]&lt;-rep(paste(names[1]),1000)
&gt; data.barplot$team[1001:2000]&lt;-rep(paste(names[2]),1000)
&gt; data.barplot$team[2001:3000]&lt;-rep(paste(names[3]),1000)
&gt; data.barplot$team[3001:4000]&lt;-rep(paste(names[4]),1000)
&gt; data.barplot$team[4001:5000]&lt;-rep(paste(names[5]),1000)
&gt; data.barplot$team[5001:6000]&lt;-rep(paste(names[6]),1000)
&gt; data.barplot$team[6001:7000]&lt;-rep(paste(names[7]),1000)
&gt; data.barplot$team[7001:8000]&lt;-rep(paste(names[8]),1000)
&gt; data.barplot$team[8001:9000]&lt;-rep(paste(names[9]),1000)
&gt; data.barplot$team[9001:10000]&lt;-rep(paste(names[10]),1000)
&gt; data.barplot$team[10001:11000]&lt;-rep(paste(names[11]),1000)
&gt; data.barplot$team[11001:12000]&lt;-rep(paste(names[12]),1000)
&gt; #data.barplot$team&lt;-as.factor(data.barplot$team)
&gt; data.barplot$team &lt;-factor(data.barplot$team, levels = c(&quot;Novara&quot;, &quot;Scandicci&quot;,&quot;Conegliano&quot;, &quot;Monza&quot;,&quot;Busto Arsizio&quot;,
+                                                          &quot;Pesaro&quot;,&quot;Piacenza&quot;, &quot;San Casciano&quot;,&quot;Casalmaggiore&quot;, &quot;Bergamo&quot;,
+                                                          &quot;Filottrano&quot;, &quot;Legnano&quot;))
&gt; 
&gt; 
&gt; 
&gt; data.barplot$match&lt;-c(rep(1,1000),rep(2,1000),rep(3,1000),rep(4,1000),rep(5,1000),rep(6,1000),
+                       rep(7,1000),rep(8,1000),rep(9,1000),rep(10,1000),rep(11,1000),rep(12,1000))
&gt; data.barplot$match&lt;-as.factor(data.barplot$match)
&gt; data.barplot$Game&lt;-rep(1,nrow(data.barplot))
&gt; data.barplot$area&lt;-ifelse(data.barplot$position==1|data.barplot$position==2|data.barplot$position==3,&quot;high&quot;,&quot;middle&quot;)
&gt; data.barplot$area&lt;-ifelse(data.barplot$position==12|data.barplot$position==11|data.barplot$position==10,&quot;low&quot;,data.barplot$area)
&gt; data.barplot$area&lt;-as.factor(data.barplot$area)
&gt; data.barplot$area&lt;-ordered(data.barplot$area,levels=c(&quot;low&quot;,&quot;middle&quot;,&quot;high&quot;))
&gt; data.barplot$team&lt;-factor(data.barplot$team,levels = rev(levels(data.barplot$team)))
&gt; 
&gt; df.summary1&lt;-ddply(data.barplot,.(team,position),summarise,count=sum(Game), percent=sum(Game)/1000)
&gt; df.summary2&lt;-ddply(data.barplot,.(team,area),summarise,count=sum(Game), percent=sum(Game)/1000)
&gt; 
&gt; ggplot(df.summary1, aes(x=team, y=percent, fill=position)) +
+   geom_bar(stat=&quot;identity&quot;, width = 0.7, colour=&quot;black&quot;, lwd=0.1) +
+   geom_text(aes(label=ifelse(percent &gt;= 0.1, paste0(sprintf(&quot;%.0f&quot;, percent*100),&quot;%&quot;),&quot;&quot;)),
+             position=position_stack(vjust=0.5), colour=&quot;white&quot;) +
+   coord_flip() + scale_y_continuous(labels = percent_format()) +
+   labs(y=&quot;&quot;, x=&quot;&quot;) + scale_fill_viridis(discrete = T) + 
+   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_rect(fill = &quot;white&quot;),
+         axis.line = element_line(colour = &quot;black&quot;))</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/plot1-1.png" width="672" /></p>
<p>The mean rankings of the teams are in line with those observed in the actual season, while also providing uncertainty about the chance of each team to end in a particular position in the league (only percentages above <span class="math inline">\(10\%\)</span> are shown for clarity).</p>
<p>The second plot compares the points trend throughout the season for each team with respect to the trend predicted by the model based on the replicated results for each match in the season.</p>
<pre class="r"><code>&gt; #########plot for cumlative points over simulated season
&gt; points.list&lt;-cum.points.list&lt;-list()
&gt; for(i in 1:nrow(res.matrix)){
+   points.list[[i]]&lt;-matrix(NA,22,12)
+   cum.points.list[[i]]&lt;-matrix(NA,22,12)
+   for(j in 1:12){
+     points.list[[i]][,j]&lt;-c(data.points.list[[i]]$points.home[data.points.list[[i]]$h==j],data.points.list[[i]]$points.away[data.points.list[[i]]$a==j])
+   }
+   colnames(points.list[[i]])&lt;-unique(levels(data$home.team))
+   rownames(points.list[[i]])&lt;-rep(1:22)
+   cum.points.list[[i]]&lt;-apply(points.list[[i]], 2, cumsum)
+ }
&gt; 
&gt; #########plot for cumlative points over simulated season
&gt; points.list&lt;-cum.points.list&lt;-list()
&gt; for(i in 1:nrow(res.matrix)){
+   points.list[[i]]&lt;-matrix(NA,22,12)
+   cum.points.list[[i]]&lt;-matrix(NA,22,12)
+   for(j in 1:12){
+     points.list[[i]][,j]&lt;-c(data.points.list[[i]]$points.home[data.points.list[[i]]$h==j],data.points.list[[i]]$points.away[data.points.list[[i]]$a==j])
+   }
+   colnames(points.list[[i]])&lt;-unique(levels(data$home.team))
+   rownames(points.list[[i]])&lt;-rep(1:22)
+   cum.points.list[[i]]&lt;-apply(points.list[[i]], 2, cumsum)
+ }
&gt; 
&gt; #plot cumulative points obs vs pred
&gt; obs.cum.points&lt;-matrix(NA,22,12)
&gt; colnames(obs.cum.points)&lt;-unique(levels(data$home.team))
&gt; rownames(obs.cum.points)&lt;-rep(1:22)
&gt; obs.cum.points[1,]&lt;-c(0,1,0,3,3,3,0,2,0,0,3,3)
&gt; obs.cum.points[2,]&lt;-c(0,3,0,3,0,0,3,3,0,3,0,3)
&gt; obs.cum.points[3,]&lt;-c(0,2,3,3,0,0,0,3,3,1,0,3)
&gt; obs.cum.points[4,]&lt;-c(0,3,0,3,0,0,3,3,1,2,0,3)
&gt; obs.cum.points[5,]&lt;-c(0,3,0,3,0,3,0,3,3,0,0,3)
&gt; obs.cum.points[6,]&lt;-c(0,3,1,3,0,0,0,3,1,3,2,2)
&gt; obs.cum.points[7,]&lt;-c(2,1,3,2,0,1,1,3,2,2,1,0)
&gt; obs.cum.points[8,]&lt;-c(0,2,1,1,0,0,3,2,3,2,1,3)
&gt; obs.cum.points[9,]&lt;-c(3,3,1,3,0,2,2,1,0,0,3,0)
&gt; obs.cum.points[10,]&lt;-c(1,2,1,2,1,2,1,1,2,2,1,2)
&gt; obs.cum.points[11,]&lt;-c(0,1,0,3,0,0,3,3,0,3,3,2)
&gt; obs.cum.points[12,]&lt;-c(3,0,0,3,0,0,3,3,3,0,0,3)
&gt; obs.cum.points[13,]&lt;-c(0,1,3,3,2,0,3,2,1,3,0,0)
&gt; obs.cum.points[14,]&lt;-c(2,3,1,3,0,0,0,3,3,0,0,3)
&gt; obs.cum.points[15,]&lt;-c(2,1,0,3,2,0,3,1,0,3,0,3)
&gt; obs.cum.points[16,]&lt;-c(0,3,0,3,0,0,0,3,3,0,3,3)
&gt; obs.cum.points[17,]&lt;-c(2,0,3,0,0,3,3,1,0,3,0,3)
&gt; obs.cum.points[18,]&lt;-c(0,0,0,3,3,1,2,3,1,2,3,0)
&gt; obs.cum.points[19,]&lt;-c(3,3,3,2,0,0,3,0,0,1,0,3)
&gt; obs.cum.points[20,]&lt;-c(0,0,2,0,3,1,0,3,3,0,3,3)
&gt; obs.cum.points[21,]&lt;-c(0,3,0,1,3,0,2,2,0,1,3,3)
&gt; obs.cum.points[22,]&lt;-c(1,1,1,0,2,0,2,3,3,2,1,2)
&gt; 
&gt; obs.cum.points&lt;-apply(obs.cum.points, 2, cumsum)
&gt; 
&gt; par(mar=c(2.1, 3.1, 3.1, 3.1))
&gt; par(mfrow=c(4,3), mai = c(0.4, 0.4, 0.1, 0.2))
&gt; for(i in 1:12){
+   plot(rep(1:22),obs.cum.points[,i], axes = F, type = &quot;n&quot;, xlab = &quot;games&quot;, ylab = &quot;points&quot;,xlim = c(0,23),ylim = c(0,54))
+   axis(1,at=c(0,5,10,15,20,25),labels = c(0,5,10,15,20,25))
+   axis(2,at=c(0,10,20,30,40,50),labels = c(0,10,20,30,40,50))
+   lines(rep(1:22),obs.cum.points[,i], lty=1,lwd=1,col=&quot;black&quot;)
+   lines(rep(1:22), cum.points.list[[7]][,i], lty=1,lwd=1,col=&quot;red&quot;)
+   text(5,50,unique(levels(names))[i],pos = 1, cex = 1)
+ }</code></pre>
<p><img src="/tutorial/glmm-stan/2020-02-01-glmm-stan_files/figure-html/plot2-1.png" width="672" /></p>
<p>The observed trends (black lines) are pretty much matched by the trends predicted by the model (red lines) for most of the teams with few exceptions. This suggests that, although the model seems to have a good predictive ability, in some cases there are still margins of improvement. In my original paper I have improved the model using a different parameterisation where I tried to account for the dependence between the latent skill parameters using a scaled inverse Wishart distribution for the covariance matrix of the random effects. Here I do not consider this model here, which lead to some improvements compared with the basic Poisson model.</p>
</div>
</div>
<div id="conclusions" class="section level1">
<h1>Conclusions</h1>
<p>One potential limitation of the framework is that only match-specific statistics are
used for estimation and prediction purposes. Ideally, the use of set-specific statistics
could improve the predictive power of the model. However, this would introduce additional problems related to the choice of the distributions for modelling the number of points scored by the opposing teams in a set, which is subject to specific constraints. Finally, the flexibility of the proposed framework allows the extension of the model in many ways. For example, additional types of in-game statistics (e.g. number of passes), if available, could be incorporated to further improve the predictions of the model; alternative distributions could also be specified to model the total number of scores <span class="math inline">\(y\)</span> during the season (e.g. Negative Binomial) which may result in a better fit to the data.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-gabrio2020bayesian" class="csl-entry">
Gabrio, Andrea. 2020. <span>“Bayesian Hierarchical Models for the Prediction of Volleyball Results.”</span> <em>Journal of Applied Statistics</em>, 1–21.
</div>
<div id="ref-gelman2015stan" class="csl-entry">
Gelman, Andrew, Daniel Lee, and Jiqiang Guo. 2015. <span>“Stan: A Probabilistic Programming Language for Bayesian Inference and Optimization.”</span> <em>Journal of Educational and Behavioral Statistics</em> 40 (5): 530–43.
</div>
<div id="ref-rstanpackage" class="csl-entry">
Stan Development Team. 2018. <span>“<span>RStan</span>: The <span>R</span> Interface to <span>Stan</span>.”</span> <a href="http://mc-stan.org/">http://mc-stan.org/</a>.
</div>
</div>
</div>
